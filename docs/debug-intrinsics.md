# Debug Intrinsics Specification for CIRCT

This document specifies the FIRRTL intrinsics generated by Chisel's Source-Level Debugging feature for integration with CIRCT's debug information lowering pipeline.

## Overview

The Source-Level Debugging feature generates two types of intrinsics:
1. `chisel.debug.module_info` - Module-level metadata
2. `chisel.debug.source_info` - Signal/Wire/Port-level metadata

These intrinsics are emitted as FIRRTL `intrinsic` statements and should be preserved through MLIR conversion for eventual lowering to DWARF debug information.

## Intrinsic Specifications

### `chisel.debug.module_info`

Captures module-level metadata including Scala class name and type information.

**Parameters:**
- `name` (String): The name of the module as defined in Scala
- `scala_class` (String): The full Scala class name (e.g., `chiselTest.MyModule$`)

**Target:** Module instance ID

**Example FIRRTL:**
```fir
intrinsic chisel.debug.module_info @mymodule is [
  name = "mymodule"
  scala_class = "chiselTest.MyModule$"
]
```

**CIRCT Lowering Target:** → `dbg.scope` with `DIModule`

---

### `chisel.debug.source_info`

Captures signal-level metadata including field names, Scala class hierarchy, and field values (for const parameters).

**Parameters:**
- `field_name` (String): The name of the field if this is a Bundle element, or the signal name
- `scala_class` (String): The full Scala class name of the type (e.g., `chiselTest.MyBundle$$anon$3`)
- `fields` (String): JSON-like string representation of field metadata for case classes / Bundles

**Target:** Signal, Wire, Register, or Port

**Example FIRRTL (simple signal):**
```fir
intrinsic chisel.debug.source_info @io.out is [
  field_name = "out"
  scala_class = "chisel3.UInt"
  fields = """[]"""
]
```

**Example FIRRTL (Bundle with fields):**
```fir
intrinsic chisel.debug.source_info @io is [
  field_name = "io"
  scala_class = "chisel.io.MyIO$"
  fields = """[{"name":"in","typeName":"UInt<8>","value":"8"},{"name":"out","typeName":"UInt<8>","value":"8"}]"""
]
```

**CIRCT Lowering Target:** → `dbg.variable` with `DICompositeType`

---

### `chisel.debug.memory_info`

Captures memory block information for proper debug modeling.

**Parameters:**
- `size` (String): Memory depth as a string
- `inner_type` (String): MLIR-like type string for element type (e.g., `!hw.int<8>`)
- `name` (String): Memory name

**Target:** Memory instance

**Example FIRRTL:**
```fir
intrinsic chisel.debug.memory_info @mem is [
  size = "16"
  inner_type = "!hw.int<8>"
  name = "mem"
]
```

---

### `chisel.debug.memory_field` (for Bundle elements)

Annotates individual fields within a Bundle-typed memory.

**Parameters:**
- `name` (String): Field name within the Bundle
- `inner_type` (String): MLIR-like type string for the field type

**Target:** Memory field reference

**Example FIRRTL:**
```fir
intrinsic chisel.debug.memory_field @mem_field_valid is [
  name = "valid"
  inner_type = "!hw.int<1>"
]

intrinsic chisel.debug.memory_field @mem_field_data is [
  name = "data"
  inner_type = "!hw.int<8>"
]
```

**CIRCT Lowering Target:** → `dbg.variable` for each Bundle field

---

### `chisel.debug.port_info`

Captures IO port direction information.

**Parameters:**
- `direction` (String): Port direction - "Input" or "Output"

**Target:** Port signal

**Example FIRRTL:**
```fir
intrinsic chisel.debug.port_info @io.in is [
  direction = "Input"
]
```

---

## Encoding Details

### Field Serialization Format

The `fields` parameter uses a JSON-like format for representing nested structures:

```json
[
  {
    "name": "fieldName",
    "typeName": "UInt<8>",
    "value": "8"
  },
  {
    "name": "nested",
    "typeName": "MyBundle",
    "fields": [...]
  }
]
```

**Supported types:**
- Primitives: `Int`, `Boolean`, `String`
- Chisel types: `UInt<width>`, `SInt<width>`, `Vec<T>[size]`, `BundleName`
- Collections: Arrays become nested field lists
- Null: Represented as empty value string

### Type Name Format

Chisel type names follow FIRRTL conventions:
- `UInt<N>`: Unsigned integer of N bits
- `SInt<N>`: Signed integer of N bits
- `Vec<T>[N]`: Vector of N elements of type T
- `BundleName`: Named Bundle type (record)
- `Clock`: Clock type
- `Reset`: Reset type

## Integration Notes

### FIRRTL to MLIR Conversion

When converting from FIRRTL to MLIR via CIRCT:
1. Preserve all `chisel.debug.*` intrinsics as `hw.intrinsic` operations
2. Maintain parameter names as string attributes
3. Pass through the `fields` parameter as-is for later parsing

### CIRCT Pass Implementation

A future CIRCT pass should:

1. **Collect Module Scopes:**
   - Find all `chisel.debug.module_info` intrinsics
   - Create `DIModule` debug metadata for each

2. **Process Signal Metadata:**
   - For each `chisel.debug.source_info` intrinsic:
     - Parse the `fields` JSON to determine type structure
     - Create `DICompositeType` or `DIBasicType` as appropriate
     - Generate `dbg.variable` operation linked to the hardware value

3. **Handle Memory Debug Info:**
   - Create memory location debug metadata using `size` and `inner_type`
   - Generate debug variables for `chisel.debug.memory_field` entries

4. **Generate DWARF:**
   - Lower all debug metadata to DWARF format in the final output

## Usage Example

```scala
class MyBundle(val width: Int) extends Bundle {
  val in = Input(UInt(width.W))
  val out = Output(UInt(width.W))
}

class MyModule(val dataWidth: Int) extends Module {
  val io = IO(new MyBundle(dataWidth))
  io.out := io.in
  val reg = RegInit(0.U(dataWidth.W))
  
  captureCircuit(this)  // Emit all debug intrinsics
}
```

Generated CHIRRTL includes:
```fir
intrinsic chisel.debug.module_info @MyModule is [...]
intrinsic chisel.debug.source_info @io is [...]
intrinsic chisel.debug.port_info @io.in is [...]
intrinsic chisel.debug.port_info @io.out is [...]
intrinsic chisel.debug.source_info @reg is [...]
```

## References

- PR #4224: Original Source-Level Debugging Implementation
- CIRCT Debug Info: https://github.com/llvm/circt/tree/main/lib/Dialect/HW
- DWARF Specification: https://dwarfstd.org/